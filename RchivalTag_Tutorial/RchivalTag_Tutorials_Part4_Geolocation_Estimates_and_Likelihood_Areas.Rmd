---
title: "RchivalTag Package Tutorial"
subtitle: 'Part 4 - Geolocation Estimates and Likelihood Areas'
author: "Dr. Robert Bauer | Data Scientist & Fishery Biologist"
date: "February 10, 2020"
output: html_document
tags: Archival Tagging data, Satellite tags, Wildlife Computers, LOTEK
---

### Principle (Pop-up)-Archival Tagging Data:

1. TAD, TAT plots per individual and all animals, season
2. PDT plot with depth tracks
3. time series data (e.g. depth and temperature)
4. tracks (Geolocation Estimates and Likelihood Areas from light levels, depth and temperature)

### Getting started:

```{r, message=FALSE}
## install or load package
# install.packages("RchivalTag")
library("RchivalTag")

## Package overview:
?RchivalTag 
help(package="RchivalTag") ## list of functions
```

Wildlife Computers exports 5 different types of tag tracks from their tags:
1. Light level based Geolocation Estimates (Maxmimum Likelihood Tracks) from GPE3 model runs stored in csv-files
2. Likelihood Areas (Probability Maps) from GPE3 model runs stored in netcdf-files
3. Likelihood Areas (Probability Maps) from GPE3 model runs stored in kmz-files (google earth format)
4. ARGOS tracks (e.g. from poped up mk10 tags, miniPATs or surfacing SPLASH tags)
5. Fastloc GPS (from surfacing SPLASH-F tags)

RchivalTag comes with a functions to read in and plot tag tracks from the different file formats (currently supported are Maxmimum Likelihood Tracks, Likelihood Areas from netcdf- and kmz-files).

## 1) How to read in and plot Maxmimum Likelihood Tracks

```{r, collapse=TRUE, message=FALSE}
## example 1a) scatter plot from csv-file:
csv_file <- system.file("example_files/15P1019-104659-1-GPE3.csv",package="RchivalTag")
pos <- get_geopos(csv_file) ## show tracks as line plot
ggplot_geopos(pos) ## shows Maxmimum Likelihood tracks as scatter plot
```

We can speed this up by running the ggplot_geopos() function directly on the csv-file:

```{r, collapse=TRUE}
## same result by direct run with ggplot_geopos()
ggplot_geopos(csv_file)
```

We can also add the track to an existing ggplot-object:

```{r, collapse=TRUE, message=FALSE}
library(oceanmap)
ggobj <- ggplotmap("lion")
ggobj2 <- ggplot_geopos(csv_file,ggobj = ggobj)
ggobj2
```

By default, ggplot_geopos() adds the tracks to a ggplot-object generated by the ggplotmap()-function from the oceanmap-package. This function comes with a lot of options to select the plotting region and style (grid, scale frame, etc.) Since the result of ggplot_geopos() is also a ggplot-object, we can adjust it like any other ggplot object to our wishes. Please refer to the oceanmap tutorial as well as the ggplotmap()-help file for further examples and options.

```{r, collapse=TRUE, message=FALSE}
ggobj <- ggplotmap("lion",grid=F,bwd=0,ticklabels = F)
ggobj2 <- ggplot_geopos(csv_file, ggobj = ggobj)
ggobj2
```

You can also add (most of) the ggplotmap-arguments to the ggplot_geopos() call.

```{r, collapse=TRUE, message=FALSE}
ggobj <- ggplot_geopos(csv_file,grid=F,bwd=0,xlim = c(2,9),ylim=c(39,44))
ggobj
```


However, you can also use another ggplot object as base map, as the followoing more manual approach illustrates.

```{r, collapse=TRUE, message=FALSE}
library("tidyverse")
library("mapview")
library("sf")
library("rnaturalearth")
library("rnaturalearthdata")
library("ggspatial")

world <- rnaturalearth::ne_countries(scale = 'small', returnclass = 'sf')

world  <- st_cast(world, 'MULTILINESTRING') %>%
  st_cast('LINESTRING', do_split=TRUE) %>%
  mutate(npts = npts(geometry, by_feature = TRUE)) %>%
  st_cast('POLYGON')

world <- ne_countries(scale = "medium", returnclass = "sf")

ggobj <- ggplot(data = world) +
  geom_sf() +
  annotation_scale(location = "bl", width_hint = 0.5) + ## add scale bar
  annotation_north_arrow(location = "bl", which_north = "true", 
                         pad_x = unit(0.75, "in"), pad_y = unit(0.5, "in"),
                         style = north_arrow_fancy_orienteering) + ## add compass
  coord_sf(xlim = c(0,10), ylim = c(38,45), expand = FALSE) + theme_minimal()

# Now let's add our track:
csv_file <- system.file("example_files/15P1019-104659-1-GPE3.csv",package="RchivalTag")
ggobj2 <- ggplot_geopos(csv_file,ggobj = ggobj)
ggobj2
```

And we can transform the figure to an interactive plotly-figure. (ATTENTION: This works probably only with the default map from the ggplotmap-function. Due to computational restrictions the ggplot object includes only islands and countries that are shown in the plotting region. It is therefore not recommended to zoom out of this region in the plotly widget. Click the home button if that is the case.

```{r, collapse=TRUE, message=FALSE}
ggobj <- ggplotmap("lion")
ggobj2 <- ggplot_geopos(csv_file,ggobj = ggobj)
ggplotly_geopos(ggobj2)
```
We can show the track as a line, or a dotted line and combine tracks:

```{r, collapse=TRUE, message=FALSE}
# ## load second file:
csv_file2 <- system.file("example_files/14P0911-46177-1-GPE3.csv",package="RchivalTag")
pos2 <- get_geopos(csv_file2)  ## show tracks as line plot
ggobj2 <- ggplot_geopos(pos2,type = "l")
ggplotly_geopos(ggobj2)

```
```{r, message=FALSE}
ggplot_geopos(rbind(pos,pos2),type = "b")
```
We can also colorize the tracks by ID instead of date.

```{r, message=FALSE}
library(ggplot2)
ggplot_geopos(rbind(pos,pos2),color_by = "DeployID")
```


```{r, collapse=TRUE, message=FALSE}
# combine tracks:
library(oceanmap)
ggobj <- ggplotmap(lon = c(-6.0, 16.5), lat=c(34.0, 44.5))
ggobj2 <- ggplot_geopos(pos,ggobj = ggobj)
ggobj3 <- ggplot_geopos(pos2,ggobj = ggobj2,zlim=range(c(pos$date,pos2$date))) # not working
ggobj3
# ggplotly_geopos(ggobj3)

```
```{r, message=FALSE}
pos3 <- rbind(pos,pos2)
ggobj3 <- ggplot_geopos(pos3,type = "l")
ggobj3 <- ggplot_geopos(pos3,type = "b")
# ggobj3 <- ggplot_geopos(pos3,type = "p")
ggplotly_geopos(ggobj3)
```
```{r, message=FALSE}
## example 1b) scatter plot from csv-file on existing landmask:
ggobj <- oceanmap::ggplotmap('lion',grid.res = 5) # use keyword to derive area limits
ggobj4 <- ggplot_geopos(csv_file,ggobj)
ggplotly_geopos(ggobj4)

# ## alternatives:
# pos <- get_geopos(csv_file)
# r <- oceanmap::regions("lion")
# ggobj5 <- ggplot_geopos(pos, xlim = r$xlim, ylim = r$ylim)
# ggplotly_geopos(ggobj5)
# 
```



```{r, collapse=TRUE, message=FALSE}
## example 2) probability surfaces of horizontal tracks from nc-file:
## this can take some time as it inlcudes time consuming data processing
nc_file <- system.file("example_files/15P1019-104659-1-GPE3.nc",package="RchivalTag")
ggobj6 <- ggplot_geopos(nc_file)
ggobj6
ggplotly_geopos(ggobj6)

# ## alternative:
# pols_df <- get_geopos(nc_file)
# ggplot_geopos(pols_df)
```

Another much faster way to plot the probability surfaces of your tag's track is to read in kmz-file which already includes the contour lines of the 50, 95 and 99% likelihood areas that are being extracted and likewise transformed to a SpatialPolygonsDataFrame. This is much faster than the netcdf-transformation process. However, the kmz-files from WC include only a subsample (up to 50) of the GPE3 likelihood areas. The use of these files is therefore only recommended for visualization purposes. Please contact WC if you are looking for a kmz-file with the complete GPE3 likelihood areas or use the netcdf-file transformation instead.


```{r, collapse=TRUE, message=FALSE}
## example 3) probability surfaces of horizontal tracks from kmz-file:
kmz_file1 <- system.file("example_files/15P1019-104659-1-GPE3.kmz",package="RchivalTag")
ggobj7 <- ggplot_geopos(kmz_file1)
ggobj7
ggplotly_geopos(ggobj7)
```

```{r, message=FALSE}
kmz_file2 <- system.file("example_files/15P0986-15P0986-2-GPE3.kmz",package="RchivalTag")
ggobj8 <- ggplot_geopos(kmz_file2)
ggobj8
ggplotly_geopos(ggobj8)
```

```{r, collapse=TRUE, message=FALSE}
k1 <- get_geopos(kmz_file1)
k2 <- get_geopos(kmz_file2)

k3 <- rbind(k1,k2)

ggobj3 <- ggplot_geopos(k3)
# ggobj3 <- ggplot_geopos(k3,ggobj = ggplotmap("lion"))
ggplotly_geopos(ggobj3)

```


```{r, message=FALSE}
ggobj <- ggplotmap("mednw4")
## p1 <- ggplot_geopos(k1,ggobj = ggobj) ## not working, need to change date format:
# k2$datetime <- k2$datetime+90*24*60*60
p1 <- ggplot_geopos(k1,grid.res=1)
p1
p2 <- ggplot_geopos(k2,p1,zlim = as.Date(range(c(k1$datetime,k2$datetime))))#,
p2
ggplotly_geopos(p2)

```

## leaflet visualizsations with RchivalTag:

```{r, collapse=TRUE, message=FALSE}
csv_file <- system.file("example_files/15P1019-104659-1-GPE3.csv",package="RchivalTag")
pos <- get_geopos(csv_file) ## show tracks as line plot
leaflet_geopos(pos,ID_label="DeployID",collapsedLayers = T) 
# leaflet_geopos(pos,ID_label="DeployID",showSlideBar = T)
```


```{r, collapse=TRUE, message=FALSE}
kmz_file <- system.file("example_files/15P1019-104659-1-GPE3.kmz",package="RchivalTag")
k1 <- get_geopos(kmz_file)
kmz_file2 <- system.file("example_files/15P0986-15P0986-2-GPE3.kmz",package="RchivalTag")
k2 <- get_geopos(kmz_file2)
k0 <- k3 <- rbind(k1,k2)

library(leaflet)
leaflet_geopos(k0,ID_label="DeployID",collapsedLayers = F) %>% addMiniMap()
leaflet_geopos(k0,ID_label="DeployID",showSlideBar = T)
```
We can add further functionalities to the leaflet map, such as a mini map to illustrate the zoom area.
```{r, message=FALSE}
k1$ID <- "12"
k1$Serial <- k1$DeployID <- c() # delete Serial field

map <- leaflet_geopos(k1,ID_label="ID")  %>% addMiniMap()
map
```

More extensions are provided by the leaflet.extras and leaflet.extras2 packages.
```{r}
library(leaflet.extras)
map %>% addMeasure(position = "bottomleft", primaryLengthUnit = "meters", #primaryAreaUnit = "hectares", 
                   activeColor = "#3D535D", completedColor = "#7D4479", localization = "en", popupOptions = list(autoClose = FALSE,latlngFormat = "DD")) %>% 
  addSearchOSM(options = searchOptions(autoCollapse = TRUE, minLength = 2, hideMarkerOnCollapse = TRUE, moveToLocation = TRUE, zoom = 14))
```


## How to integrate geolocation estimates with your time series data:

```{r, collapse=TRUE, message=FALSE}
### combine geolocation estimates with the time series data:
ts_file <- system.file("example_files/104659-Series.csv",package="RchivalTag")
ts_df <- read_TS(ts_file)
head(ts_df)
pos <- get_geopos(csv_file)
head(pos)

library(plyr)
input <- pos[,c("date","Lon","Lat")]
add <- ddply(input,.(date),function(x) c(Lon=mean(x$Lon),Lat=mean(x$Lat)))
out <- merge(ts_df,add,by="date")
out <- out[order(out$datetime),]

out <- classify_DayTime(out)
plot_DepthTS(out,plot_DayTimePeriods = T)
```








